// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// FrameSyncClient is the client API for FrameSync service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FrameSyncClient interface {
	CS_PlayerReady(ctx context.Context, in *PlayerReady, opts ...grpc.CallOption) (*Empty, error)
	CS_PlayerOperations(ctx context.Context, in *LogicFrame, opts ...grpc.CallOption) (*Empty, error)
	CS_PlayerResumeGame(ctx context.Context, in *PlayerResumeGame, opts ...grpc.CallOption) (*Empty, error)
	CS_PlayerOver(ctx context.Context, in *PlayerOver, opts ...grpc.CallOption) (*Empty, error)
	CS_RoomHistory(ctx context.Context, in *ReqRoomHistory, opts ...grpc.CallOption) (*Empty, error)
	CS_RoomBaseInfo(ctx context.Context, in *RoomBaseInfo, opts ...grpc.CallOption) (*Empty, error)
	CS_PlayerState(ctx context.Context, in *PlayerBase, opts ...grpc.CallOption) (*Empty, error)
	CS_Heartbeat(ctx context.Context, in *Heartbeat, opts ...grpc.CallOption) (*Empty, error)
	SC_ReadyTimeout(ctx context.Context, in *ReadyTimeout, opts ...grpc.CallOption) (*Empty, error)
	SC_EnterBattle(ctx context.Context, in *EnterBattle, opts ...grpc.CallOption) (*Empty, error)
	SC_LogicFrame(ctx context.Context, in *LogicFrame, opts ...grpc.CallOption) (*Empty, error)
	SC_RoomHistory(ctx context.Context, in *RoomHistorySets, opts ...grpc.CallOption) (*Empty, error)
	SC_RoomBaseInfo(ctx context.Context, in *RoomBaseInfo, opts ...grpc.CallOption) (*Empty, error)
	SC_OtherPlayerOffline(ctx context.Context, in *OtherPlayerOffline, opts ...grpc.CallOption) (*Empty, error)
	SC_OtherPlayerOver(ctx context.Context, in *PlayerOver, opts ...grpc.CallOption) (*Empty, error)
	SC_OtherPlayerResumeGame(ctx context.Context, in *PlayerResumeGame, opts ...grpc.CallOption) (*Empty, error)
	SC_StartBattle(ctx context.Context, in *StartBattle, opts ...grpc.CallOption) (*Empty, error)
	SC_RestartGame(ctx context.Context, in *RestartGame, opts ...grpc.CallOption) (*Empty, error)
	SC_GameOver(ctx context.Context, in *GameOver, opts ...grpc.CallOption) (*Empty, error)
	SC_PlayerState(ctx context.Context, in *PlayerState, opts ...grpc.CallOption) (*Empty, error)
	SC_Heartbeat(ctx context.Context, in *Heartbeat, opts ...grpc.CallOption) (*Empty, error)
	FdClose(ctx context.Context, in *FDCloseEvent, opts ...grpc.CallOption) (*Empty, error)
	FdCreate(ctx context.Context, in *FDCreateEvent, opts ...grpc.CallOption) (*Empty, error)
}

type frameSyncClient struct {
	cc grpc.ClientConnInterface
}

func NewFrameSyncClient(cc grpc.ClientConnInterface) FrameSyncClient {
	return &frameSyncClient{cc}
}

func (c *frameSyncClient) CS_PlayerReady(ctx context.Context, in *PlayerReady, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/pb.FrameSync/CS_PlayerReady", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *frameSyncClient) CS_PlayerOperations(ctx context.Context, in *LogicFrame, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/pb.FrameSync/CS_PlayerOperations", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *frameSyncClient) CS_PlayerResumeGame(ctx context.Context, in *PlayerResumeGame, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/pb.FrameSync/CS_PlayerResumeGame", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *frameSyncClient) CS_PlayerOver(ctx context.Context, in *PlayerOver, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/pb.FrameSync/CS_PlayerOver", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *frameSyncClient) CS_RoomHistory(ctx context.Context, in *ReqRoomHistory, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/pb.FrameSync/CS_RoomHistory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *frameSyncClient) CS_RoomBaseInfo(ctx context.Context, in *RoomBaseInfo, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/pb.FrameSync/CS_RoomBaseInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *frameSyncClient) CS_PlayerState(ctx context.Context, in *PlayerBase, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/pb.FrameSync/CS_PlayerState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *frameSyncClient) CS_Heartbeat(ctx context.Context, in *Heartbeat, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/pb.FrameSync/CS_Heartbeat", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *frameSyncClient) SC_ReadyTimeout(ctx context.Context, in *ReadyTimeout, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/pb.FrameSync/SC_ReadyTimeout", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *frameSyncClient) SC_EnterBattle(ctx context.Context, in *EnterBattle, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/pb.FrameSync/SC_EnterBattle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *frameSyncClient) SC_LogicFrame(ctx context.Context, in *LogicFrame, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/pb.FrameSync/SC_LogicFrame", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *frameSyncClient) SC_RoomHistory(ctx context.Context, in *RoomHistorySets, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/pb.FrameSync/SC_RoomHistory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *frameSyncClient) SC_RoomBaseInfo(ctx context.Context, in *RoomBaseInfo, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/pb.FrameSync/SC_RoomBaseInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *frameSyncClient) SC_OtherPlayerOffline(ctx context.Context, in *OtherPlayerOffline, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/pb.FrameSync/SC_OtherPlayerOffline", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *frameSyncClient) SC_OtherPlayerOver(ctx context.Context, in *PlayerOver, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/pb.FrameSync/SC_OtherPlayerOver", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *frameSyncClient) SC_OtherPlayerResumeGame(ctx context.Context, in *PlayerResumeGame, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/pb.FrameSync/SC_OtherPlayerResumeGame", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *frameSyncClient) SC_StartBattle(ctx context.Context, in *StartBattle, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/pb.FrameSync/SC_StartBattle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *frameSyncClient) SC_RestartGame(ctx context.Context, in *RestartGame, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/pb.FrameSync/SC_RestartGame", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *frameSyncClient) SC_GameOver(ctx context.Context, in *GameOver, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/pb.FrameSync/SC_GameOver", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *frameSyncClient) SC_PlayerState(ctx context.Context, in *PlayerState, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/pb.FrameSync/SC_PlayerState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *frameSyncClient) SC_Heartbeat(ctx context.Context, in *Heartbeat, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/pb.FrameSync/SC_Heartbeat", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *frameSyncClient) FdClose(ctx context.Context, in *FDCloseEvent, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/pb.FrameSync/FdClose", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *frameSyncClient) FdCreate(ctx context.Context, in *FDCreateEvent, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/pb.FrameSync/FdCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FrameSyncServer is the server API for FrameSync service.
// All implementations must embed UnimplementedFrameSyncServer
// for forward compatibility
type FrameSyncServer interface {
	CS_PlayerReady(context.Context, *PlayerReady) (*Empty, error)
	CS_PlayerOperations(context.Context, *LogicFrame) (*Empty, error)
	CS_PlayerResumeGame(context.Context, *PlayerResumeGame) (*Empty, error)
	CS_PlayerOver(context.Context, *PlayerOver) (*Empty, error)
	CS_RoomHistory(context.Context, *ReqRoomHistory) (*Empty, error)
	CS_RoomBaseInfo(context.Context, *RoomBaseInfo) (*Empty, error)
	CS_PlayerState(context.Context, *PlayerBase) (*Empty, error)
	CS_Heartbeat(context.Context, *Heartbeat) (*Empty, error)
	SC_ReadyTimeout(context.Context, *ReadyTimeout) (*Empty, error)
	SC_EnterBattle(context.Context, *EnterBattle) (*Empty, error)
	SC_LogicFrame(context.Context, *LogicFrame) (*Empty, error)
	SC_RoomHistory(context.Context, *RoomHistorySets) (*Empty, error)
	SC_RoomBaseInfo(context.Context, *RoomBaseInfo) (*Empty, error)
	SC_OtherPlayerOffline(context.Context, *OtherPlayerOffline) (*Empty, error)
	SC_OtherPlayerOver(context.Context, *PlayerOver) (*Empty, error)
	SC_OtherPlayerResumeGame(context.Context, *PlayerResumeGame) (*Empty, error)
	SC_StartBattle(context.Context, *StartBattle) (*Empty, error)
	SC_RestartGame(context.Context, *RestartGame) (*Empty, error)
	SC_GameOver(context.Context, *GameOver) (*Empty, error)
	SC_PlayerState(context.Context, *PlayerState) (*Empty, error)
	SC_Heartbeat(context.Context, *Heartbeat) (*Empty, error)
	FdClose(context.Context, *FDCloseEvent) (*Empty, error)
	FdCreate(context.Context, *FDCreateEvent) (*Empty, error)
	mustEmbedUnimplementedFrameSyncServer()
}

// UnimplementedFrameSyncServer must be embedded to have forward compatible implementations.
type UnimplementedFrameSyncServer struct {
}

func (UnimplementedFrameSyncServer) CS_PlayerReady(context.Context, *PlayerReady) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CS_PlayerReady not implemented")
}
func (UnimplementedFrameSyncServer) CS_PlayerOperations(context.Context, *LogicFrame) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CS_PlayerOperations not implemented")
}
func (UnimplementedFrameSyncServer) CS_PlayerResumeGame(context.Context, *PlayerResumeGame) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CS_PlayerResumeGame not implemented")
}
func (UnimplementedFrameSyncServer) CS_PlayerOver(context.Context, *PlayerOver) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CS_PlayerOver not implemented")
}
func (UnimplementedFrameSyncServer) CS_RoomHistory(context.Context, *ReqRoomHistory) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CS_RoomHistory not implemented")
}
func (UnimplementedFrameSyncServer) CS_RoomBaseInfo(context.Context, *RoomBaseInfo) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CS_RoomBaseInfo not implemented")
}
func (UnimplementedFrameSyncServer) CS_PlayerState(context.Context, *PlayerBase) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CS_PlayerState not implemented")
}
func (UnimplementedFrameSyncServer) CS_Heartbeat(context.Context, *Heartbeat) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CS_Heartbeat not implemented")
}
func (UnimplementedFrameSyncServer) SC_ReadyTimeout(context.Context, *ReadyTimeout) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SC_ReadyTimeout not implemented")
}
func (UnimplementedFrameSyncServer) SC_EnterBattle(context.Context, *EnterBattle) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SC_EnterBattle not implemented")
}
func (UnimplementedFrameSyncServer) SC_LogicFrame(context.Context, *LogicFrame) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SC_LogicFrame not implemented")
}
func (UnimplementedFrameSyncServer) SC_RoomHistory(context.Context, *RoomHistorySets) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SC_RoomHistory not implemented")
}
func (UnimplementedFrameSyncServer) SC_RoomBaseInfo(context.Context, *RoomBaseInfo) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SC_RoomBaseInfo not implemented")
}
func (UnimplementedFrameSyncServer) SC_OtherPlayerOffline(context.Context, *OtherPlayerOffline) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SC_OtherPlayerOffline not implemented")
}
func (UnimplementedFrameSyncServer) SC_OtherPlayerOver(context.Context, *PlayerOver) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SC_OtherPlayerOver not implemented")
}
func (UnimplementedFrameSyncServer) SC_OtherPlayerResumeGame(context.Context, *PlayerResumeGame) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SC_OtherPlayerResumeGame not implemented")
}
func (UnimplementedFrameSyncServer) SC_StartBattle(context.Context, *StartBattle) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SC_StartBattle not implemented")
}
func (UnimplementedFrameSyncServer) SC_RestartGame(context.Context, *RestartGame) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SC_RestartGame not implemented")
}
func (UnimplementedFrameSyncServer) SC_GameOver(context.Context, *GameOver) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SC_GameOver not implemented")
}
func (UnimplementedFrameSyncServer) SC_PlayerState(context.Context, *PlayerState) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SC_PlayerState not implemented")
}
func (UnimplementedFrameSyncServer) SC_Heartbeat(context.Context, *Heartbeat) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SC_Heartbeat not implemented")
}
func (UnimplementedFrameSyncServer) FdClose(context.Context, *FDCloseEvent) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FdClose not implemented")
}
func (UnimplementedFrameSyncServer) FdCreate(context.Context, *FDCreateEvent) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FdCreate not implemented")
}
func (UnimplementedFrameSyncServer) mustEmbedUnimplementedFrameSyncServer() {}

// UnsafeFrameSyncServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FrameSyncServer will
// result in compilation errors.
type UnsafeFrameSyncServer interface {
	mustEmbedUnimplementedFrameSyncServer()
}

func RegisterFrameSyncServer(s grpc.ServiceRegistrar, srv FrameSyncServer) {
	s.RegisterService(&FrameSync_ServiceDesc, srv)
}

func _FrameSync_CS_PlayerReady_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlayerReady)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FrameSyncServer).CS_PlayerReady(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.FrameSync/CS_PlayerReady",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FrameSyncServer).CS_PlayerReady(ctx, req.(*PlayerReady))
	}
	return interceptor(ctx, in, info, handler)
}

func _FrameSync_CS_PlayerOperations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogicFrame)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FrameSyncServer).CS_PlayerOperations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.FrameSync/CS_PlayerOperations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FrameSyncServer).CS_PlayerOperations(ctx, req.(*LogicFrame))
	}
	return interceptor(ctx, in, info, handler)
}

func _FrameSync_CS_PlayerResumeGame_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlayerResumeGame)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FrameSyncServer).CS_PlayerResumeGame(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.FrameSync/CS_PlayerResumeGame",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FrameSyncServer).CS_PlayerResumeGame(ctx, req.(*PlayerResumeGame))
	}
	return interceptor(ctx, in, info, handler)
}

func _FrameSync_CS_PlayerOver_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlayerOver)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FrameSyncServer).CS_PlayerOver(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.FrameSync/CS_PlayerOver",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FrameSyncServer).CS_PlayerOver(ctx, req.(*PlayerOver))
	}
	return interceptor(ctx, in, info, handler)
}

func _FrameSync_CS_RoomHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqRoomHistory)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FrameSyncServer).CS_RoomHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.FrameSync/CS_RoomHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FrameSyncServer).CS_RoomHistory(ctx, req.(*ReqRoomHistory))
	}
	return interceptor(ctx, in, info, handler)
}

func _FrameSync_CS_RoomBaseInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoomBaseInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FrameSyncServer).CS_RoomBaseInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.FrameSync/CS_RoomBaseInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FrameSyncServer).CS_RoomBaseInfo(ctx, req.(*RoomBaseInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _FrameSync_CS_PlayerState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlayerBase)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FrameSyncServer).CS_PlayerState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.FrameSync/CS_PlayerState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FrameSyncServer).CS_PlayerState(ctx, req.(*PlayerBase))
	}
	return interceptor(ctx, in, info, handler)
}

func _FrameSync_CS_Heartbeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Heartbeat)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FrameSyncServer).CS_Heartbeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.FrameSync/CS_Heartbeat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FrameSyncServer).CS_Heartbeat(ctx, req.(*Heartbeat))
	}
	return interceptor(ctx, in, info, handler)
}

func _FrameSync_SC_ReadyTimeout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadyTimeout)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FrameSyncServer).SC_ReadyTimeout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.FrameSync/SC_ReadyTimeout",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FrameSyncServer).SC_ReadyTimeout(ctx, req.(*ReadyTimeout))
	}
	return interceptor(ctx, in, info, handler)
}

func _FrameSync_SC_EnterBattle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnterBattle)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FrameSyncServer).SC_EnterBattle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.FrameSync/SC_EnterBattle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FrameSyncServer).SC_EnterBattle(ctx, req.(*EnterBattle))
	}
	return interceptor(ctx, in, info, handler)
}

func _FrameSync_SC_LogicFrame_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogicFrame)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FrameSyncServer).SC_LogicFrame(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.FrameSync/SC_LogicFrame",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FrameSyncServer).SC_LogicFrame(ctx, req.(*LogicFrame))
	}
	return interceptor(ctx, in, info, handler)
}

func _FrameSync_SC_RoomHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoomHistorySets)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FrameSyncServer).SC_RoomHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.FrameSync/SC_RoomHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FrameSyncServer).SC_RoomHistory(ctx, req.(*RoomHistorySets))
	}
	return interceptor(ctx, in, info, handler)
}

func _FrameSync_SC_RoomBaseInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoomBaseInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FrameSyncServer).SC_RoomBaseInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.FrameSync/SC_RoomBaseInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FrameSyncServer).SC_RoomBaseInfo(ctx, req.(*RoomBaseInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _FrameSync_SC_OtherPlayerOffline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OtherPlayerOffline)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FrameSyncServer).SC_OtherPlayerOffline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.FrameSync/SC_OtherPlayerOffline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FrameSyncServer).SC_OtherPlayerOffline(ctx, req.(*OtherPlayerOffline))
	}
	return interceptor(ctx, in, info, handler)
}

func _FrameSync_SC_OtherPlayerOver_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlayerOver)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FrameSyncServer).SC_OtherPlayerOver(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.FrameSync/SC_OtherPlayerOver",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FrameSyncServer).SC_OtherPlayerOver(ctx, req.(*PlayerOver))
	}
	return interceptor(ctx, in, info, handler)
}

func _FrameSync_SC_OtherPlayerResumeGame_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlayerResumeGame)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FrameSyncServer).SC_OtherPlayerResumeGame(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.FrameSync/SC_OtherPlayerResumeGame",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FrameSyncServer).SC_OtherPlayerResumeGame(ctx, req.(*PlayerResumeGame))
	}
	return interceptor(ctx, in, info, handler)
}

func _FrameSync_SC_StartBattle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartBattle)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FrameSyncServer).SC_StartBattle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.FrameSync/SC_StartBattle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FrameSyncServer).SC_StartBattle(ctx, req.(*StartBattle))
	}
	return interceptor(ctx, in, info, handler)
}

func _FrameSync_SC_RestartGame_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RestartGame)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FrameSyncServer).SC_RestartGame(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.FrameSync/SC_RestartGame",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FrameSyncServer).SC_RestartGame(ctx, req.(*RestartGame))
	}
	return interceptor(ctx, in, info, handler)
}

func _FrameSync_SC_GameOver_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GameOver)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FrameSyncServer).SC_GameOver(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.FrameSync/SC_GameOver",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FrameSyncServer).SC_GameOver(ctx, req.(*GameOver))
	}
	return interceptor(ctx, in, info, handler)
}

func _FrameSync_SC_PlayerState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlayerState)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FrameSyncServer).SC_PlayerState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.FrameSync/SC_PlayerState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FrameSyncServer).SC_PlayerState(ctx, req.(*PlayerState))
	}
	return interceptor(ctx, in, info, handler)
}

func _FrameSync_SC_Heartbeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Heartbeat)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FrameSyncServer).SC_Heartbeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.FrameSync/SC_Heartbeat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FrameSyncServer).SC_Heartbeat(ctx, req.(*Heartbeat))
	}
	return interceptor(ctx, in, info, handler)
}

func _FrameSync_FdClose_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FDCloseEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FrameSyncServer).FdClose(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.FrameSync/FdClose",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FrameSyncServer).FdClose(ctx, req.(*FDCloseEvent))
	}
	return interceptor(ctx, in, info, handler)
}

func _FrameSync_FdCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FDCreateEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FrameSyncServer).FdCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.FrameSync/FdCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FrameSyncServer).FdCreate(ctx, req.(*FDCreateEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// FrameSync_ServiceDesc is the grpc.ServiceDesc for FrameSync service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FrameSync_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.FrameSync",
	HandlerType: (*FrameSyncServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CS_PlayerReady",
			Handler:    _FrameSync_CS_PlayerReady_Handler,
		},
		{
			MethodName: "CS_PlayerOperations",
			Handler:    _FrameSync_CS_PlayerOperations_Handler,
		},
		{
			MethodName: "CS_PlayerResumeGame",
			Handler:    _FrameSync_CS_PlayerResumeGame_Handler,
		},
		{
			MethodName: "CS_PlayerOver",
			Handler:    _FrameSync_CS_PlayerOver_Handler,
		},
		{
			MethodName: "CS_RoomHistory",
			Handler:    _FrameSync_CS_RoomHistory_Handler,
		},
		{
			MethodName: "CS_RoomBaseInfo",
			Handler:    _FrameSync_CS_RoomBaseInfo_Handler,
		},
		{
			MethodName: "CS_PlayerState",
			Handler:    _FrameSync_CS_PlayerState_Handler,
		},
		{
			MethodName: "CS_Heartbeat",
			Handler:    _FrameSync_CS_Heartbeat_Handler,
		},
		{
			MethodName: "SC_ReadyTimeout",
			Handler:    _FrameSync_SC_ReadyTimeout_Handler,
		},
		{
			MethodName: "SC_EnterBattle",
			Handler:    _FrameSync_SC_EnterBattle_Handler,
		},
		{
			MethodName: "SC_LogicFrame",
			Handler:    _FrameSync_SC_LogicFrame_Handler,
		},
		{
			MethodName: "SC_RoomHistory",
			Handler:    _FrameSync_SC_RoomHistory_Handler,
		},
		{
			MethodName: "SC_RoomBaseInfo",
			Handler:    _FrameSync_SC_RoomBaseInfo_Handler,
		},
		{
			MethodName: "SC_OtherPlayerOffline",
			Handler:    _FrameSync_SC_OtherPlayerOffline_Handler,
		},
		{
			MethodName: "SC_OtherPlayerOver",
			Handler:    _FrameSync_SC_OtherPlayerOver_Handler,
		},
		{
			MethodName: "SC_OtherPlayerResumeGame",
			Handler:    _FrameSync_SC_OtherPlayerResumeGame_Handler,
		},
		{
			MethodName: "SC_StartBattle",
			Handler:    _FrameSync_SC_StartBattle_Handler,
		},
		{
			MethodName: "SC_RestartGame",
			Handler:    _FrameSync_SC_RestartGame_Handler,
		},
		{
			MethodName: "SC_GameOver",
			Handler:    _FrameSync_SC_GameOver_Handler,
		},
		{
			MethodName: "SC_PlayerState",
			Handler:    _FrameSync_SC_PlayerState_Handler,
		},
		{
			MethodName: "SC_Heartbeat",
			Handler:    _FrameSync_SC_Heartbeat_Handler,
		},
		{
			MethodName: "FdClose",
			Handler:    _FrameSync_FdClose_Handler,
		},
		{
			MethodName: "FdCreate",
			Handler:    _FrameSync_FdCreate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "frame_sync.proto",
}
