// Code generated by protoc-gen-go. DO NOT EDIT.
// source: game_match.proto

package pb

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type PlayerMatchSign struct {
	PlayerId             int32    `protobuf:"varint,1,opt,name=player_id,json=playerId,proto3" json:"player_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PlayerMatchSign) Reset()         { *m = PlayerMatchSign{} }
func (m *PlayerMatchSign) String() string { return proto.CompactTextString(m) }
func (*PlayerMatchSign) ProtoMessage()    {}
func (*PlayerMatchSign) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a724bc5c4547e83, []int{0}
}

func (m *PlayerMatchSign) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PlayerMatchSign.Unmarshal(m, b)
}
func (m *PlayerMatchSign) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PlayerMatchSign.Marshal(b, m, deterministic)
}
func (m *PlayerMatchSign) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlayerMatchSign.Merge(m, src)
}
func (m *PlayerMatchSign) XXX_Size() int {
	return xxx_messageInfo_PlayerMatchSign.Size(m)
}
func (m *PlayerMatchSign) XXX_DiscardUnknown() {
	xxx_messageInfo_PlayerMatchSign.DiscardUnknown(m)
}

var xxx_messageInfo_PlayerMatchSign proto.InternalMessageInfo

func (m *PlayerMatchSign) GetPlayerId() int32 {
	if m != nil {
		return m.PlayerId
	}
	return 0
}

type PlayerMatchSignCancel struct {
	PlayerId             int32    `protobuf:"varint,1,opt,name=player_id,json=playerId,proto3" json:"player_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PlayerMatchSignCancel) Reset()         { *m = PlayerMatchSignCancel{} }
func (m *PlayerMatchSignCancel) String() string { return proto.CompactTextString(m) }
func (*PlayerMatchSignCancel) ProtoMessage()    {}
func (*PlayerMatchSignCancel) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a724bc5c4547e83, []int{1}
}

func (m *PlayerMatchSignCancel) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PlayerMatchSignCancel.Unmarshal(m, b)
}
func (m *PlayerMatchSignCancel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PlayerMatchSignCancel.Marshal(b, m, deterministic)
}
func (m *PlayerMatchSignCancel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlayerMatchSignCancel.Merge(m, src)
}
func (m *PlayerMatchSignCancel) XXX_Size() int {
	return xxx_messageInfo_PlayerMatchSignCancel.Size(m)
}
func (m *PlayerMatchSignCancel) XXX_DiscardUnknown() {
	xxx_messageInfo_PlayerMatchSignCancel.DiscardUnknown(m)
}

var xxx_messageInfo_PlayerMatchSignCancel proto.InternalMessageInfo

func (m *PlayerMatchSignCancel) GetPlayerId() int32 {
	if m != nil {
		return m.PlayerId
	}
	return 0
}

type PlayerMatchSignFailed struct {
	PlayerId             int32    `protobuf:"varint,1,opt,name=player_id,json=playerId,proto3" json:"player_id,omitempty"`
	Msg                  string   `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	Code                 int32    `protobuf:"varint,3,opt,name=code,proto3" json:"code,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PlayerMatchSignFailed) Reset()         { *m = PlayerMatchSignFailed{} }
func (m *PlayerMatchSignFailed) String() string { return proto.CompactTextString(m) }
func (*PlayerMatchSignFailed) ProtoMessage()    {}
func (*PlayerMatchSignFailed) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a724bc5c4547e83, []int{2}
}

func (m *PlayerMatchSignFailed) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PlayerMatchSignFailed.Unmarshal(m, b)
}
func (m *PlayerMatchSignFailed) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PlayerMatchSignFailed.Marshal(b, m, deterministic)
}
func (m *PlayerMatchSignFailed) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlayerMatchSignFailed.Merge(m, src)
}
func (m *PlayerMatchSignFailed) XXX_Size() int {
	return xxx_messageInfo_PlayerMatchSignFailed.Size(m)
}
func (m *PlayerMatchSignFailed) XXX_DiscardUnknown() {
	xxx_messageInfo_PlayerMatchSignFailed.DiscardUnknown(m)
}

var xxx_messageInfo_PlayerMatchSignFailed proto.InternalMessageInfo

func (m *PlayerMatchSignFailed) GetPlayerId() int32 {
	if m != nil {
		return m.PlayerId
	}
	return 0
}

func (m *PlayerMatchSignFailed) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *PlayerMatchSignFailed) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

type PlayerMatchingFailed struct {
	PlayerId             int32    `protobuf:"varint,1,opt,name=player_id,json=playerId,proto3" json:"player_id,omitempty"`
	Msg                  string   `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	RoomId               string   `protobuf:"bytes,3,opt,name=roomId,proto3" json:"roomId,omitempty"`
	Code                 int32    `protobuf:"varint,4,opt,name=code,proto3" json:"code,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PlayerMatchingFailed) Reset()         { *m = PlayerMatchingFailed{} }
func (m *PlayerMatchingFailed) String() string { return proto.CompactTextString(m) }
func (*PlayerMatchingFailed) ProtoMessage()    {}
func (*PlayerMatchingFailed) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a724bc5c4547e83, []int{3}
}

func (m *PlayerMatchingFailed) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PlayerMatchingFailed.Unmarshal(m, b)
}
func (m *PlayerMatchingFailed) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PlayerMatchingFailed.Marshal(b, m, deterministic)
}
func (m *PlayerMatchingFailed) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlayerMatchingFailed.Merge(m, src)
}
func (m *PlayerMatchingFailed) XXX_Size() int {
	return xxx_messageInfo_PlayerMatchingFailed.Size(m)
}
func (m *PlayerMatchingFailed) XXX_DiscardUnknown() {
	xxx_messageInfo_PlayerMatchingFailed.DiscardUnknown(m)
}

var xxx_messageInfo_PlayerMatchingFailed proto.InternalMessageInfo

func (m *PlayerMatchingFailed) GetPlayerId() int32 {
	if m != nil {
		return m.PlayerId
	}
	return 0
}

func (m *PlayerMatchingFailed) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *PlayerMatchingFailed) GetRoomId() string {
	if m != nil {
		return m.RoomId
	}
	return ""
}

func (m *PlayerMatchingFailed) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func init() {
	proto.RegisterType((*PlayerMatchSign)(nil), "pb.PlayerMatchSign")
	proto.RegisterType((*PlayerMatchSignCancel)(nil), "pb.PlayerMatchSignCancel")
	proto.RegisterType((*PlayerMatchSignFailed)(nil), "pb.PlayerMatchSignFailed")
	proto.RegisterType((*PlayerMatchingFailed)(nil), "pb.PlayerMatchingFailed")
}

func init() { proto.RegisterFile("game_match.proto", fileDescriptor_7a724bc5c4547e83) }

var fileDescriptor_7a724bc5c4547e83 = []byte{
	// 278 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x12, 0x48, 0x4f, 0xcc, 0x4d,
	0x8d, 0xcf, 0x4d, 0x2c, 0x49, 0xce, 0xd0, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0x62, 0x2a, 0x48,
	0x92, 0xe2, 0x49, 0xce, 0xcf, 0xcd, 0xcd, 0xcf, 0x83, 0x88, 0x28, 0xe9, 0x71, 0xf1, 0x07, 0xe4,
	0x24, 0x56, 0xa6, 0x16, 0xf9, 0x82, 0x94, 0x05, 0x67, 0xa6, 0xe7, 0x09, 0x49, 0x73, 0x71, 0x16,
	0x80, 0x85, 0xe2, 0x33, 0x53, 0x24, 0x18, 0x15, 0x18, 0x35, 0x58, 0x83, 0x38, 0x20, 0x02, 0x9e,
	0x29, 0x4a, 0x26, 0x5c, 0xa2, 0x68, 0xea, 0x9d, 0x13, 0xf3, 0x92, 0x53, 0x73, 0xf0, 0xeb, 0x8a,
	0xc2, 0xd0, 0xe5, 0x96, 0x98, 0x99, 0x93, 0x9a, 0x82, 0x57, 0x97, 0x90, 0x00, 0x17, 0x73, 0x6e,
	0x71, 0xba, 0x04, 0x93, 0x02, 0xa3, 0x06, 0x67, 0x10, 0x88, 0x29, 0x24, 0xc4, 0xc5, 0x92, 0x9c,
	0x9f, 0x92, 0x2a, 0xc1, 0x0c, 0x56, 0x09, 0x66, 0x2b, 0x15, 0x72, 0x89, 0x20, 0x99, 0x9d, 0x99,
	0x97, 0x4e, 0x9e, 0xd1, 0x62, 0x5c, 0x6c, 0x45, 0xf9, 0xf9, 0xb9, 0x9e, 0x29, 0x60, 0xc3, 0x39,
	0x83, 0xa0, 0x3c, 0xb8, 0x95, 0x2c, 0x08, 0x2b, 0x8d, 0x7a, 0x99, 0xb8, 0x38, 0xdd, 0x13, 0x73,
	0x53, 0xc1, 0x36, 0x0a, 0x99, 0x71, 0x09, 0x39, 0x07, 0xc7, 0xa3, 0x87, 0xa2, 0xb0, 0x5e, 0x41,
	0x92, 0x1e, 0x9a, 0xa0, 0x14, 0x27, 0x48, 0xd0, 0x35, 0xb7, 0xa0, 0xa4, 0x52, 0x89, 0x41, 0xc8,
	0x89, 0x4b, 0x02, 0x53, 0x1f, 0x34, 0x34, 0x25, 0xb1, 0xe8, 0x86, 0x48, 0x61, 0x98, 0x11, 0xec,
	0x1c, 0x8f, 0x3d, 0x6c, 0xb1, 0x99, 0x01, 0x91, 0x42, 0x35, 0xc3, 0x81, 0x4b, 0x1c, 0xd5, 0x0c,
	0x44, 0x18, 0x4a, 0xa0, 0x19, 0x01, 0x97, 0x41, 0x31, 0xc1, 0x89, 0x3d, 0x8a, 0x55, 0x4f, 0xdf,
	0xba, 0x20, 0x29, 0x89, 0x0d, 0x9c, 0xa8, 0x8c, 0x01, 0x01, 0x00, 0x00, 0xff, 0xff, 0x27, 0xb9,
	0x6a, 0x2f, 0x7a, 0x02, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// GameMatchClient is the client API for GameMatch service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type GameMatchClient interface {
	CS_PlayerMatchSign(ctx context.Context, in *PlayerMatchSign, opts ...grpc.CallOption) (*Empty, error)
	CS_PlayerMatchSignCancel(ctx context.Context, in *PlayerMatchSignCancel, opts ...grpc.CallOption) (*Empty, error)
	SC_PlayerMatchSignFailed(ctx context.Context, in *PlayerMatchSignFailed, opts ...grpc.CallOption) (*Empty, error)
	SC_PlayerMatchingFailed(ctx context.Context, in *PlayerMatchingFailed, opts ...grpc.CallOption) (*Empty, error)
}

type gameMatchClient struct {
	cc *grpc.ClientConn
}

func NewGameMatchClient(cc *grpc.ClientConn) GameMatchClient {
	return &gameMatchClient{cc}
}

func (c *gameMatchClient) CS_PlayerMatchSign(ctx context.Context, in *PlayerMatchSign, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/pb.GameMatch/CS_PlayerMatchSign", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gameMatchClient) CS_PlayerMatchSignCancel(ctx context.Context, in *PlayerMatchSignCancel, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/pb.GameMatch/CS_PlayerMatchSignCancel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gameMatchClient) SC_PlayerMatchSignFailed(ctx context.Context, in *PlayerMatchSignFailed, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/pb.GameMatch/SC_PlayerMatchSignFailed", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gameMatchClient) SC_PlayerMatchingFailed(ctx context.Context, in *PlayerMatchingFailed, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/pb.GameMatch/SC_PlayerMatchingFailed", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GameMatchServer is the server API for GameMatch service.
type GameMatchServer interface {
	CS_PlayerMatchSign(context.Context, *PlayerMatchSign) (*Empty, error)
	CS_PlayerMatchSignCancel(context.Context, *PlayerMatchSignCancel) (*Empty, error)
	SC_PlayerMatchSignFailed(context.Context, *PlayerMatchSignFailed) (*Empty, error)
	SC_PlayerMatchingFailed(context.Context, *PlayerMatchingFailed) (*Empty, error)
}

// UnimplementedGameMatchServer can be embedded to have forward compatible implementations.
type UnimplementedGameMatchServer struct {
}

func (*UnimplementedGameMatchServer) CS_PlayerMatchSign(ctx context.Context, req *PlayerMatchSign) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CS_PlayerMatchSign not implemented")
}
func (*UnimplementedGameMatchServer) CS_PlayerMatchSignCancel(ctx context.Context, req *PlayerMatchSignCancel) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CS_PlayerMatchSignCancel not implemented")
}
func (*UnimplementedGameMatchServer) SC_PlayerMatchSignFailed(ctx context.Context, req *PlayerMatchSignFailed) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SC_PlayerMatchSignFailed not implemented")
}
func (*UnimplementedGameMatchServer) SC_PlayerMatchingFailed(ctx context.Context, req *PlayerMatchingFailed) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SC_PlayerMatchingFailed not implemented")
}

func RegisterGameMatchServer(s *grpc.Server, srv GameMatchServer) {
	s.RegisterService(&_GameMatch_serviceDesc, srv)
}

func _GameMatch_CS_PlayerMatchSign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlayerMatchSign)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GameMatchServer).CS_PlayerMatchSign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.GameMatch/CS_PlayerMatchSign",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GameMatchServer).CS_PlayerMatchSign(ctx, req.(*PlayerMatchSign))
	}
	return interceptor(ctx, in, info, handler)
}

func _GameMatch_CS_PlayerMatchSignCancel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlayerMatchSignCancel)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GameMatchServer).CS_PlayerMatchSignCancel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.GameMatch/CS_PlayerMatchSignCancel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GameMatchServer).CS_PlayerMatchSignCancel(ctx, req.(*PlayerMatchSignCancel))
	}
	return interceptor(ctx, in, info, handler)
}

func _GameMatch_SC_PlayerMatchSignFailed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlayerMatchSignFailed)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GameMatchServer).SC_PlayerMatchSignFailed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.GameMatch/SC_PlayerMatchSignFailed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GameMatchServer).SC_PlayerMatchSignFailed(ctx, req.(*PlayerMatchSignFailed))
	}
	return interceptor(ctx, in, info, handler)
}

func _GameMatch_SC_PlayerMatchingFailed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlayerMatchingFailed)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GameMatchServer).SC_PlayerMatchingFailed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.GameMatch/SC_PlayerMatchingFailed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GameMatchServer).SC_PlayerMatchingFailed(ctx, req.(*PlayerMatchingFailed))
	}
	return interceptor(ctx, in, info, handler)
}

var _GameMatch_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.GameMatch",
	HandlerType: (*GameMatchServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CS_PlayerMatchSign",
			Handler:    _GameMatch_CS_PlayerMatchSign_Handler,
		},
		{
			MethodName: "CS_PlayerMatchSignCancel",
			Handler:    _GameMatch_CS_PlayerMatchSignCancel_Handler,
		},
		{
			MethodName: "SC_PlayerMatchSignFailed",
			Handler:    _GameMatch_SC_PlayerMatchSignFailed_Handler,
		},
		{
			MethodName: "SC_PlayerMatchingFailed",
			Handler:    _GameMatch_SC_PlayerMatchingFailed_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "game_match.proto",
}
